##############################
# author : qianqiu
# email : qianqiu@tencent.com
# time : 2022.1.7
##############################
import os
from jinja2 import FileSystemLoader, Environment


class PluginTemplate(object):
    """
    Fill in the useable params which generated by PluginTemplateParams to plugin template.
    The plugin template is compatible with TensorRT-8.0.
    """

    def __init__(
        self,
        template_params,
        TEMPLATE_HEADER_FILE="./trt_plugin/trt8.0_plugin_h_dynamic.template",
        TEMPLATE_SOURCE_FILE="./trt_plugin/trt8.0_plugin_cu_dynamic.template",
    ):
        self._template_header_file = TEMPLATE_HEADER_FILE
        self._template_source_file = TEMPLATE_SOURCE_FILE
        self._plugin_name = template_params.plugin_name
        self._plugin_config = template_params.plugin_config
        templateLoader = FileSystemLoader(searchpath="./")
        self._templateEnv = Environment(loader=templateLoader)
        self._plugin_output_number = template_params.output_num
        self._plugin_output_type = template_params.output_type
        self._plugin_workspace_size = template_params.workspace_size
        onnx_output_shape = template_params.output_shape
        self._plugin_output_shape = self.parse_plugin_output_shape(onnx_output_shape)
        onnx_tensor_type = template_params.tensor_type
        self._plugin_tensor_format = self.parse_plugin_tensor_format(onnx_tensor_type)
        kernel_order = template_params.kernel_order
        workspace_init = template_params.workspace_init
        self._plugin_kernels_params = self.parse_plugin_kernels_params(kernel_order)
        self._plugin_constant_init = self.parse_plugin_workspace_init(workspace_init)
        self._plugin_kernels_body = template_params.cuda_source_code

    class tensor_dims:
        def __init__(self, nbDims, shape):
            self.nbDims = nbDims
            self.shape = tuple(shape)

    class tensor_format:
        def __init__(self, format, type):
            self.format = format
            self.type = type

    class kernel:
        def __init__(
            self,
            name,
            grid_dim,
            block_dim,
            enqueue_params,
            kernel_params=None,
            code=None,
        ):
            self.name = name
            self.grid_dim = grid_dim
            self.block_dim = block_dim
            self.enqueue_params = enqueue_params
            self.kernel_params = kernel_params
            self.code = code

    class constant:
        def __init__(self, pos, value, type, index, length):
            self.pos = pos
            self.value = value
            self.type = type
            self.index = index
            self.length = length

    def parse_plugin_output_shape(self, onnx_output_shape):
        plugin_output_shape = []
        for s in onnx_output_shape:
            ### ignore batch dimension for IPluginV2IOExt interface
            # nbDims = len(s) - 1
            # shape = s[1:]
            ### preserve batch dimension for IPluginV2DynamicExt interface
            nbDims = len(s)
            shape = s
            plugin_output_shape.append(self.tensor_dims(nbDims, shape))
        return plugin_output_shape

    def parse_plugin_tensor_format(self, onnx_tensor_type):
        plugin_tensor_format = []
        for dtype in onnx_tensor_type:
            plugin_tensor_format.append(self.tensor_format("LINEAR", dtype))
        return plugin_tensor_format

    def parse_plugin_kernels_params(self, kernel_order):
        kernel_call = {}
        plugin_kernels_params = []
        for func_name in kernel_order:
            if func_name not in kernel_call.keys():
                kernel_call[func_name] = 0
                key_name = func_name
            else:
                kernel_call[func_name] += 1
                key_name = func_name + "_" + str(kernel_call[func_name])
            plugin_kernels_params.append(
                self.kernel(
                    func_name,
                    self._plugin_config[key_name]["grid_dim"],
                    self._plugin_config[key_name]["block_dim"],
                    self._plugin_config[key_name]["enqueue_params"],
                )
            )
        return plugin_kernels_params

    def parse_plugin_workspace_init(self, workspace_init):
        plugin_constant_init = []
        for init_constant in workspace_init.items():
            value_str = ""
            for ele in init_constant[1][0]:
                value_str = value_str + str(ele) + " ,"
            value_str = value_str.strip(",")
            plugin_constant_init.append(
                self.constant(
                    init_constant[0],
                    # init_constant[1][0],
                    value_str,
                    init_constant[1][1],
                    init_constant[1][2],
                    len(init_constant[1][0]),
                )
            )
        return plugin_constant_init

    def genearte_header_file(self):
        template = self._templateEnv.get_template(self._template_header_file)
        outputText = template.render(
            plugin_name=self._plugin_name,
            plugin_output_number=self._plugin_output_number,
            plugin_output_shape=self._plugin_output_shape,
            plugin_output_type=self._plugin_output_type,
            plugin_workspace_size=self._plugin_workspace_size,
            plugin_tensor_format=self._plugin_tensor_format,
        )
        with open("./trt_plugin/src/{}.h".format(self._plugin_name), "w") as f:
            f.write(outputText)

    def genearte_source_file(self):
        template = self._templateEnv.get_template(self._template_source_file)
        outputText = template.render(
            plugin_name=self._plugin_name,
            plugin_kernels_params=self._plugin_kernels_params,
            plugin_kernels_body=self._plugin_kernels_body,
            plugin_constant_init=self._plugin_constant_init,
        )
        with open("./trt_plugin/src/{}.cu".format(self._plugin_name), "w") as f:
            f.write(outputText)

    def build_plugin(self):
        os.chdir("./trt_plugin")
        os.system(f"make clean plugin_name={self._plugin_name}")
        os.system(f"make plugin_name={self._plugin_name}")
        os.chdir("../")

    def fill(self):
        plugin_header_path = f"./trt_plugin/src/{self._plugin_name}.h"
        plugin_source_path = f"./trt_plugin/src/{self._plugin_name}.cu"
        if os.path.isfile(plugin_header_path):
            os.remove(plugin_header_path)
        if os.path.isfile(plugin_source_path):
            os.remove(plugin_source_path)
        self.genearte_header_file()
        self.genearte_source_file()
        self.build_plugin()
